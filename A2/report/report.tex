\documentclass[12pt]{article}

\usepackage{graphicx}
\usepackage{paralist}
\usepackage{listings}
\usepackage{booktabs}

\oddsidemargin 0mm
\evensidemargin 0mm
\textwidth 160mm
\textheight 200mm

\pagestyle {plain}
\pagenumbering{arabic}

\newcounter{stepnum}

\title{Assignment 2 Solution}
\author{Joshua Guinness, guinnesj, 400134735}
\date{\today}

\begin {document}

\maketitle

In this assignment, a program was created to place students into their second year engineering stream
based on their GPA, free choice, and preference of stream. This assignment was implemented by following a formal
specification. The results of testing, comments on the specification, as well as answers to other questions are in the below sections.

\section{Testing of the Original Program}

The approach to testing that was taken was to first test the basic functionality of each function in each module
given the input data in the text files to ensure everything worked. Then the more boundary and weird cases would be tested.
Because of the time constraint, only 15 test cases were created instead of the high amount that were planned. Thus, the test cases that were implemented, focused on ensuring the basic functionality of the program and checking
to see whether key functions in certain modules worked correctly and behaved as specified. All 15 test cases passed. There
were no problems uncovered while testing but that is likely because the testing was not thourough enough to uncover potential errors.

\section{Results of Testing Partner's Code}

After running the test cases on the partner's code, 11 of the 15 test cases passed and 4 failed. Three of the four that failed
were just assertions checking the department capacity immediately after reading in the file of department capacities. The reason these
failed is because the value returned by the partners code is a string, while it is comparing it to an int. This is an error
in the partner implementation. The fourth test case failed due to an error in their allocate() function in the SALst module. In their
code, they tried to see whether an int value was less than a string, an operation obviously not supported therefore raising a TypeError.
This is again an error in the implementation of their code. However, the 11 that did pass did so because of correct implementation due
to following the specification. Having more test cases may have exposed more errors in implementation.

\section{Critique of Given Design Specification}

This specification was a lot more formal and had a lot less flexibility than
the previous specification for Assignment 1. This had both disadvantages and
advantages. 

The main advantage is that the project structure, and implementation were
crystal clear, leaving little room for misinterpretation or assumptions.
As a programmer, not having to make assumptions makes coding much easier 
because certain things don't have to be accounted for e.g. bad input, and
one spends less time thinking about the different assumptions one is 
making and whether they are valid or not. In terms of the implementation
being specified, this is really advantageous because it separates the coding
from the planning, meaning when your coding your coding, and when your
planning your planning. It is easy to fall into the trap of planning while
coding but this is bad because there is a lack of direction and organization
and time ends up being wasted by constantly changing it. The formal
specification helps enforce the idea of planning before coding, making the
time spent coding much more productive. One final advantage is that although
the specification was very formal about how the modules are laid out and the
exact functions in each module, it left how the functions are to be coded
relatively open, allowing each programmer to code in their own style.

There are two main disadvantages of the specification that was given in this
assignment. The first is that the formal language can often be hard to read
and thus interpret. The high level of formality was occasionally difficult
to understand what exactly was supposed to be changing, or happening, and in
what circumstance. An example of this is the output specification for the
sort function in the SALst module. A second disadvantage is that there is no
high level overview of how all the modules are supposed to work together,
rather it is left to the reader/programmer to figure out. This can be
quite difficult and take a while and often leads to programming and implementing
the modules without understanding how they work together.

Based on the comments above, two design changes that would benefit the
intended audience of the specification are to give a high level overview
of how all the modules work together, and english explanations to complicated
formal specification statements. The first of these suggestions will help
the reader understand the over flow and organization of the program without
having to read the formal specification multiple times. This will give the
programmer a better idea of how things work together and allow them to get
started quicker. The second suggestion, will make more clear long formal
statements, again, allowing the programming to understand and implement
quicker.

To conlude, the formal specification is a great tool that drastically
decreases the number of assumptions being made and ambiguous statements.
It also enforces planning before programming making the implementation easier.
However, it can be harder to understand how modules work together and the meaning
behind long statements which is why improvements should be made in that regard.

\section{Answers}

\begin{enumerate}

\item Contrast the natural language of A1 to the formal specification of A2.
What are the advantages and disadvantages of each approach?

A few of the advantages and disadvantages were talked about in the previous
section but they will be repeated here as well as added on to.

The natural language of A1 made is easy to understand what the program was
trying to accomplish, and how it was going to do that. It was really clear
how the different modules were going to work together and depend on each
other. The natural language also made it easy to understand what the purpose
of each function would be. This is its main advantage, its easy of understand.
Its disadvntage, however, is its ambiguity and openness. The lack of detail
in the natural specification leads the reader confused exactly how things
are supposed to be implemented, forcing many assumptions to be made. A further
disadvantage is that the natural specification allows one to program without
technically planning first, leading to wasted time, re-writing code,
and planning while coding which is not a good idea.

The main advantage of the formal specification of A2 is how clear everything is
made and the fact that very few, if nothing is left to assumption or guesswork.
It also further specified how to implement the code, leaving less planning
in the hands of the programmer, leading to more productivity and a more accurate
implementation. Its drawback lies in the fact that it can often be hard to read
and observe how all the modules work together.

\item The specification makes the assumption that the gpa will be between 0 and 12.
How would you modify the specification to change this assumption to an exception?
Would you need to modify the specification to replace a record type with a new ADT?

To modify the specification to change this assumption to an exception, it will just specify an exception that when
a GPA that is not between 0 and 12 occurs, an exception is raised. A good place to implement this would be in
the add method in SALst as this is when a student is added to a list of students. The GPA of the student can then be
easily checked, raising an exception if the value is out of bounds. Another place this could possibly be done is in the
Read module. Although the specification would not need to be changed to replace a record type with a new ADT, it would likely
be better, and result in a cleaner implementation and would be easier to change in the future. With it implemented as an ADT,
custom functions could also be added which would benefit the programs as well.

\item If we ignore the functions sort, average and allocate, the two modules SALst and DCapALst
are very similar. Ignoring the functions mentioned, how could the documentation be modified 
to take advantage of the similarities?

The documentation can be modified to take advantage of the similarities between SALst and DCapALst 
by reusing sections and just identifying which key elements or variables need to change between modules.
To be more specific, the documentation for one function will be used for both functions, with some additional
notes about what specifically in the function will change or be different between modules. This is a good idea because 
it will cut down on the amount of writing and show how similar things are, though it does have the downside of potentially 
being more confusing.

\item A1 had a question about generality of an interface. In what ways is A2 more general
than A1?

A2 is more general than A1 in that there is more freedom in the implementation within the functions.
A1 was pretty specific in regards to exactly how the code in the functions should be written while A2
has more freedom in that sense. A2 also has less restrictions in the exact data type to use, choosing
instead to just specify a tuple, but leaving it open how the tuple should be implemented. A1 was much
more specific in this sense, detailing exactly the data type to use, which was a dictionary in most cases,
with no leeway.

\item The list of choices for each student is represented by a custom object, SeqADT, instead of a
Python list. For this specific usage, what are the advantages of using SeqADT over a regular list?

An advantage of representing the list of choices for each student as a custom object, in this case SeqADT,
is that custom operations can be defined on them, often making them easier to use. For this specific usage,
SeqADT has the functions start, next, and end, which enable the client to use the object in different ways
than it would be able to do with just a list. THe next() function is especially helpful because it provides
iterating through the sequence much easier than trying to iterate through a list on the client side.

\item Many of the strings in A1 have been replaced by enums in A2. For these cases, what advantages do enums provide?
Why weren't enums also introduced in the specification for macids?

Enums provide the advantage in that there is only a specific set of values that can be chosen, massively reducing 
the margin of error. Enums are especially useful for constants. In the case for this assignment, enumerated types are used for gender and engineering departments.
This means that students will have a guarenteed value that has meaning, this also means less error checking has to be in place
when using enumerated types. Enums were not introduced in the specification for macids because macids are of an infinite
variety, meaning they are variables. Macids cannot be pre-planned and therefore cannot be enums.

\end{enumerate}

\newpage

\lstset{language=Python, basicstyle=\tiny, breaklines=true, showspaces=false,
  showstringspaces=false, breakatwhitespace=true}
%\lstset{language=C,linewidth=.94\textwidth,xleftmargin=1.1cm}

\def\thesection{\Alph{section}}

\section{Code for StdntAllocTypes.py}

\noindent \lstinputlisting{../src/StdntAllocTypes.py}

\newpage

\section{Code for SeqADT.py}

\noindent \lstinputlisting{../src/SeqADT.py}

\newpage

\section{Code for DCapALst.py}

\noindent \lstinputlisting{../src/DCapALst.py}

\newpage

\section{Code for AALst.py}

\noindent \lstinputlisting{../src/AALst.py}

\newpage

\section{Code for SALst.py}

\noindent \lstinputlisting{../src/SALst.py}

\newpage

\section{Code for Read.py}

\noindent \lstinputlisting{../src/Read.py}

\newpage

\section{Code for testAll.py}

\noindent \lstinputlisting{../src/test_All.py}

\newpage

\section{Code for Partner's SeqADT.py}

\noindent \lstinputlisting{../partner/SeqADT.py}

\newpage

\section{Code for Partner's DCapALst.py}

\noindent \lstinputlisting{../partner/DCapALst.py}

\newpage

\section{Code for Partner's SALst.py}

\noindent \lstinputlisting{../partner/SALst.py}

\end {document}