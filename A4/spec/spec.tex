\documentclass[12pt]{article}

\usepackage{graphicx}
\usepackage{paralist}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{hhline}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage{multicol}
\usepackage{url}

\oddsidemargin -10mm
\evensidemargin -10mm
\textwidth 160mm
\textheight 200mm
\renewcommand\baselinestretch{1.0}

\pagestyle {plain}
\pagenumbering{arabic}

\newcounter{stepnum}

%% Comments

\usepackage{color}

\newif\ifcomments\commentstrue

\ifcomments
\newcommand{\authornote}[3]{\textcolor{#1}{[#3 ---#2]}}
\newcommand{\todo}[1]{\textcolor{red}{[TODO: #1]}}
\else
\newcommand{\authornote}[3]{}
\newcommand{\todo}[1]{}
\fi

\newcommand{\wss}[1]{\authornote{blue}{SS}{#1}}

\title{Assignment 4, Specification}
\author{SFWR ENG 2AA4}

\begin {document}

\maketitle
\begin{center}
    Joshua Guinness, guinnesj, 400134735
\end{center}
\medskip

This Module Interface Specification (MIS) document contains modules, types and
methods for implementing the state of a game of Conway's Game of Life

In applying the specification, there will be cases that involve undefinedness.
We will interpret undefinedness following~\cite{Farmer2004}:

If $p: \alpha_1 \times .... \times \alpha_n \rightarrow \mathbb{B}$ and any of
$a_1, ..., a_n$ is undefined, then $p(a_1, ..., a_n)$ is False.  For instance,
if $p(x) = 1/x < 1$, then $p(0) = \text{False}$.  In the language of our
specification, if evaluating an expression generates an exception, then the
value of the expression is undefined.

\bibliographystyle{plain}
\bibliography{SmithCollectedRefs}

\newpage

\section* {Cell ADT Module}

\subsection*{Module}

Cell

\subsection* {Uses}

N/A

\subsection* {Syntax}

\subsubsection* {Exported Constants}

None

\subsubsection* {Exported Types}

Cell = ?

\subsubsection* {Exported Access Programs}

\begin{tabular}{| l | l | l | p{5cm} |}
\hline
\textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\hline
new Cell & & Cell & none\\
\hline
new Cell & boolean & Cell & none\\
\hline
get\_life & & boolean & none\\
\hline
get\_neighbours & & int & none\\
\hline
set\_life & boolean & & none\\
\hline
set\_neighbours & int & & out\_of\_range\\
\hline
\end{tabular}

\subsection* {Semantics}

\subsubsection* {State Variables}

$S$: boolean \textit{\# Alive or Dead}\\
$N$: int \textit{\# Number of neighbors}

\subsubsection* {State Invariant}

$n \leq 8$

\subsubsection* {Assumptions and Design Decisions}

\begin{itemize}
    \item The Cell(S) or Cell() constructor is called for each object instance before any other access routine is called for that object. The constructor can only be called once.
\end{itemize}

\subsubsection* {Access Routine Semantics}

new Cell():
\begin{itemize}
    \item transition: $S, N := false, 0$
    \item output: $\mathit{out := self}$
    \item exception: none
\end{itemize}

\noindent
new Cell($s$):
\begin{itemize}
    \item transition: $S, N := s, 0$
    \item output: $\mathit{out := self}$
    \item exception: none
\end{itemize}

\noindent
get\_life():
\begin{itemize}
    \item output: $\mathit{out := S}$
    \item exception: none
\end{itemize}

\noindent
get\_neighbours():
\begin{itemize}
    \item output: $\mathit{out := N}$
    \item exception: none
\end{itemize}

\noindent
set\_life(s):
\begin{itemize}
    \item transition: $\mathit{S := s}$
    \item output: none
    \item exception: none
\end{itemize}

\noindent
set\_neighbours(n):
\begin{itemize}
    \item transition: $\mathit{N := n}$
    \item output: none
    \item exception: $\mathit{exc := (n > 6} \Rightarrow out\_of\_range)$
\end{itemize}

\newpage

\section* {Game Board ADT Module}

\subsection*{Template Module}

BoardT

\subsection* {Uses}

\noindent Cell\\
\noindent View

\subsection* {Syntax}

\subsubsection* {Exported Constants}

None

\subsubsection* {Exported Types}

BoardT

\subsubsection* {Exported Access Programs}

\begin{tabular}{| l | l | l | l |}
\hline
\textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\hline
new BoardT  & seq of (seq of C) & BoardT & invalid\_argument\\
\hline
next & & &\\
\hline
view & & &\\
\hline

\hline
\end{tabular}

\subsection* {Semantics}

\subsubsection* {State Variables}

$C$: seq of (seq of Cell) $\mathit{\# 2D \ Array \ of \ Cells}$

\subsubsection* {State Invariant}

$|seq \ of \ Cell| = |seq \ of \ (seq \ of \ Cell)|$ $\mathit{\# 2D \ array 
\ is \ a \ perfect \ square}$

\subsubsection* {Assumptions \& Design Decisions}

\begin{itemize}

\item The BoardT constructor is called before any other access
  routine is called on that instance. Once a BoardT has been created, the
  constructor will not be called on it again.
  
\item The seq of (seq of C) that is passed to the constructor is a perfect square. This means
that both sequences are of the same length.

\item For better scalability, this module is specified as an Abstract Data Type
  (ADT) instead of an Abstract Object. This would allow multiple games to be
  created and tracked at once by a client.
  
\item The view() function calls the view module which displays the current state of the game.

\end{itemize}

\subsubsection* {Access Routine Semantics}

new BoardT(c):
\begin{itemize}
    \item transition: $C := c$
    \item output: $out := self$
    \item exception: invalid\_argument
\end{itemize}

\noindent
next():
\begin{itemize}
    \item transition: $C := update\_neighbours\_middle(), update\_neighbours\_leftside(), \\ update\_neighbours\_rightside(),
    update\_neighbours\_top(), update\_neighbours\_bottom(), update\_corners()\\
    update\_cells()$
    
    \item output: none
    \item exception: none
\end{itemize}

\noindent
view():
\begin{itemize}
    \item transition: none
    \item output: none
    \item exception: none
\end{itemize}

\subsection*{Local Types}

None

\subsection*{Local Functions}

\noindent
update\_neighbours\_middle: \\
update\_neighbours\_middle() $\equiv$ $\forall i : \mathbb{N} \ | \ i \in [1..|seq \ of \ C|] \ : \ (\forall j : \mathbb{N} \ | \ j \in [1..|seq \ of \ C|] \ : \ C[i][j].set\_neighbours(C[i-1][j-1] + C[i-1][j] + C[i-1][j+1] + C[i][j-1] + C[i][j+1] + C[i+1][j-1] + C[i+1][j] + C[i+1][j+1]))$ \\

\noindent
update\_neighbours\_leftside: \\
update\_neighbours\_leftside() $\equiv$ $\forall i : \mathbb{N} | i \in [1..|seq \ of \ C|-2] : C[i][0].set\_neighbours(C[i-1][0] + C[i-1][1] + C[i][1] + C[i+1][1] + C[i+1][0])$ \\

\noindent
update\_neighbours\_rightside: \\
update\_neighbours\_rightside() $\equiv$ $\forall i : \mathbb{N} | i \in [1..|seq \ of \ C|-2] : C[i][|seq \ of \ C|-2].set\_neighbours(C[i-1][|seq \ of \ C|-2] + C[i-1][|seq \ of \ C|-3] + C[i][|seq \ of \ C|-3] + C[i+1][|seq \ of \ C|-3] + C[i+1][|seq \ of \ C|-2])$ \\

\noindent
update\_neighbours\_top\\
update\_neighbours\_top() $\equiv$ $\forall i : \mathbb{N} | j \in [1..|seq \ of \ C|-2] : C[0][j].set\_neighbours(C[0][j-1] + C[1][j-1] + C[1][j] + C[1][j+1] + C[0][j+1|])$ \\

\noindent
update\_neighbours\_bottom: \\
update\_neighbours\_bottom() $\equiv$ $\forall i : \mathbb{N} | j \in [1..|seq \ of \ C|-2] : C[|seq \ of \ C|-2][j].set\_neighbours(C[|seq \ of \ C|-2][j-1] + C[|seq \ of \ C|-3][j-1] + C[|seq \ of \ C|-3][j] + C[|seq \ of \ C|-3][j+1] + C[|seq \ of \ C|-2][j+1|])$ \\

\noindent
update\_corners: \\
update\_corners() $\equiv$ \\
$C[0][0].set\_neighbours(C[0][1] + C[1][1] + C[1][0])$\\
$C[0][|seq \ of \ C|-1].set\_neighbours(C[0][|seq \ of \ C|-2] + C[1][|seq \ of \ C|-2] + C[1][|seq \ of \ C|-1])$\\
$C[|seq \ of \ C|-1][0].set\_neighbours(C[|seq \ of \ C|-2][0] + C[|seq \ of \ C|-2][1] + C[|seq \ of \ C|-1][1])$\\
$C[|seq \ of \ C|-1][|seq \ of \ C|-1].set\_neighbours(C[|seq \ of \ C|-1][|seq \ of \ C|-2] + C[|seq \ of \ C|-2][|seq \ of \ C|-2] + C[|seq \ of \ C|-2][|seq \ of \ C|-1])$\\

\noindent
update\_cells:\\
update\_cells() $\equiv$ \\
$\forall x : Cell \ . \ x \in C \land x.get\_life = true\ | \ ((x.get\_neighbours \leq 1 \Rightarrow x.set\_life := false) \lor 
(x.get\_neighbours \ge 4 \Rightarrow x.set\_life := false) \lor
(x.get\_neighbours > 1 \land x.get\_neighbours < 4 \Rightarrow x.set\_life := true))$ \\

$\forall x : Cell \ . \ x \in C \land x.get\_life = False \ | \ 
((x.get\_neighbours = 3 \Rightarrow x.set\_life := alive) \lor
(x.get\_neighbours() > 3 \lor x.get\_neighbours < 3 \Rightarrow x.set\_life() := false))$

\newpage

\section* {Read Module}

\subsection*{Module}

Read

\subsection* {Uses}

BoardT
Cell

\subsection* {Syntax}

\subsubsection* {Exported Constants}

None

\subsubsection* {Exported Types}

None

\subsubsection* {Exported Access Programs}

\begin{tabular}{| l | l | l | p{5cm} |}
\hline
\textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\hline
read\_state & String & seq of (seq of Cell) & filesystem\_error\\
\hline
\end{tabular}

\subsection* {Semantics}

\subsubsection* {State Variables}

None

\subsubsection* {State Invariant}

None

\subsubsection* {Assumptions and Design Decisions}

\begin{itemize}
    \item The contents of the file are in the right format
\end{itemize}

\subsubsection* {Access Routine Semantics}

\newpage

\section* {View Module}

\subsection*{Module}

View

\subsection* {Uses}

BoardT
Cell

\subsection* {Syntax}

\subsubsection* {Exported Constants}

None

\subsubsection* {Exported Types}

None

\subsubsection* {Exported Access Programs}

\begin{tabular}{| l | l | l | p{5cm} |}
\hline
\textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\hline
view\_state & seq of (seq of Cell) & &\\
\hline
\end{tabular}

\subsection* {Semantics}

\subsubsection* {State Variables}

None

\subsubsection* {State Invariant}

None

\subsubsection* {Assumptions and Design Decisions}

\subsubsection* {Access Routine Semantics}

\newpage

\section*{Critique of Design}

\end {document}

